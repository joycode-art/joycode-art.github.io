<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="utf-8">
  <title>实现正交设计</title>

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="this is meta description">
  <meta name="author" content="JoyCode Inc.">
  <meta name="generator" content="Hugo 0.80.0" />

  <!-- plugins -->
  
  <link rel="stylesheet" href="https://joycode-art.github.io/plugins/bootstrap/bootstrap.min.css">
  
  <link rel="stylesheet" href="https://joycode-art.github.io/plugins/themify-icons/themify-icons.css">
  
  <link rel="stylesheet" href="https://joycode-art.github.io/plugins/slick/slick.css">
  
  <link rel="stylesheet" href="https://joycode-art.github.io/plugins/slick/slick-theme.css">
  
  <link rel="stylesheet" href="https://joycode-art.github.io/plugins/aos/aos.css">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="https://joycode-art.github.io/scss/style.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="https://joycode-art.github.io/images/favicon.png" type="image/x-icon">
  <link rel="icon" href="https://joycode-art.github.io/images/favicon.png" type="image/x-icon">

  
  <meta property="og:image" content="https://joycode-art.github.io/images/blogs/007.png" />
  
  <meta property="og:title" content="实现正交设计" />
<meta property="og:description" content="this is meta description" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://joycode-art.github.io/blog/02-impl-design/" />
<meta property="article:published_time" content="2020-03-14T15:40:24+06:00" />
<meta property="article:modified_time" content="2020-03-14T15:40:24+06:00" />

  

</head><body id="top" data-spy="scroll" data-target="#navbar-spy" class="position-relative">
<!-- preloader start -->
<div class="preloader position-fixed d-flex align-items-center justify-content-center">
  <div class="block">
    <div class="loader-image mb-20">
      <img src="images/preloader.png" alt="">
    </div>
    <h2 class="loader-text text-uppercase">
      <span class="h3 font-weight-light mb-1">Welcome to</span>
      <span class="font-weight-bold">JoyCode</span>
    </h2>
  </div> 
</div>
<!-- preloader end -->
<header class="header-nav position-relative">
    <div class="container">
      <nav class="navbar navbar-expand-xl navbar-light px-0">
        <a class="navbar-brand p-0" href="https://joycode-art.github.io">
          
          <img class="img-fluid" src="https://joycode-art.github.io/images/logo.png" alt="JoyCode: A Hardcore Software Consultancy | JoyCode">
          
        </a>

        <button class="navbar-toggler bg-white rounded-0 p-0" type="button" data-toggle="collapse"
          data-target="#navlinks" aria-controls="navlinks" aria-expanded="false" aria-label="Toggle navigation">
          <svg class="nav-toggle-icon" viewBox="0 0 100 100" width="40" onclick="this.classList.toggle('active')">
            <path class="line top"
              d="m 70,33 h -40 c 0,0 -8.5,-0.149796 -8.5,8.5 0,8.649796 8.5,8.5 8.5,8.5 h 20 v -20" />
            <path class="line middle" d="m 70,50 h -40" />
            <path class="line bottom"
              d="m 30,67 h 40 c 0,0 8.5,0.149796 8.5,-8.5 0,-8.649796 -8.5,-8.5 -8.5,-8.5 h -20 v 20" /></svg>
        </button>
        

        <div class="collapse navbar-collapse" id="navlinks">
          <ul class="navbar-nav mx-auto">
            
            
            <li class="nav-item">
              <a class="nav-link" href="https://joycode-art.github.io/">主页</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="https://joycode-art.github.io/solution">解决方案</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="https://joycode-art.github.io/story">咨询案例</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="https://joycode-art.github.io/conference">技术大会</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="https://joycode-art.github.io/training">企业培训</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="https://joycode-art.github.io/blog">技术洞见</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="https://joycode-art.github.io/team">关于我们</a>
            </li>
            
            
            
          </ul>
        </div>
        
      </nav>
    </div>
  </header>

  
  <section class="section-padding pt-50">
    <div class="container">
      <div class="row justify-content-center">
        
        <div class="col-lg-9 col-md-12 mb-60" data-aos="fade-in" data-aos-delay="50">
          <div class="post-category position-relative mb-15"><a
            href="/categories/%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1" class="text-black-200 font-weight-600 ml-1">软件设计 </a>
            
          </div>

          <h2 class="font-weight-bold mb-30">实现正交设计</h2>

          <div class="post-meta font-weight-600 text-primary mb-15">
            <a target="_blank" class="text-primary" href="https://joycode.art/team/02-liuguangcong/">刘光聪</a>
            <span class="mx-2">|</span>
            <span>14 Mar, 2020</span>
            <span class="mx-2">|</span>
            <span>5 Mins Read</span>
          </div>
          <div class="content"><h2 id="软件设计的目标">软件设计的目标</h2>
<p>软件设计就是为了完成如下目标，其可验证性、重要程度依次减低。</p>
<ul>
<li>实现功能</li>
<li>易于重用</li>
<li>易于理解</li>
<li>没有冗余</li>
</ul>
<h3 id="实现功能">实现功能</h3>
<p>实现功能的目标压倒一起，这也是软件设计的首要标准。如何判定系统功能的完备性呢？通过所有测试用例。</p>
<p>从<code>TDD</code>的角度看，测试用例就是对需求的阐述，是一个闭环的反馈系统，保证其系统的正确性；及其保证设计的合理性，恰如其分，不多不少；当然也是理解系统行为最重要的依据。</p>
<h3 id="易于理解">易于理解</h3>
<p>好的设计应该能让其他人也能容易地理解，包括系统的行为，业务的规则。那么，什么样的设计才算得上易于理解的呢？</p>
<ul>
<li><code>Clean Code</code></li>
<li><code>Implement Patterns</code></li>
<li><code>Idioms</code></li>
</ul>
<h3 id="没有冗余">没有冗余</h3>
<p>没有冗余的系统是最简单的系统，恰如其分的系统，不做任何过度设计的系统。</p>
<ul>
<li><code>Dead Code</code></li>
<li><code>YAGNI: You Ain't Gonna Need It</code></li>
<li><code>KISS: Keep it Simple, Stupid</code></li>
</ul>
<h3 id="易于重用">易于重用</h3>
<p>易于重用的软件结构，使得其应对变化更具弹性；可被容易地修改，具有更加适应变化的能力。</p>
<p>最理想的情况下，所有的软件修改都具有局部性。但现实并非如此，软件设计往往需要花费很大的精力用于依赖的管理，让组件之间的关系变得清晰、一致、漂亮。</p>
<p>那么软件设计的最高准则是什么呢？「高内聚、低耦合」原则是提高可重用性的最高原则。为了实现高内聚，低耦合的软件设计，袁英杰提出了「正交设计」的方法论。</p>
<h2 id="正交设计">正交设计</h2>
<p>「正交」是一个数学概念：所谓正交，就是指两个向量的内积为零。简单的说，就是这两个向量是垂直的。在一个正交系统里，沿着一个方向的变化，其另外一个方向不会发生变化。为此，<code>Bob</code>大叔将「职责」定义为「变化的原因」。</p>
<p>「正交性」，意味着更高的内聚，更低的耦合。为此，正交性可以用于衡量系统的可重用性。那么，如何保证设计的正交性呢？袁英杰提出了「正交设计的四个基本原则」，简明扼要，道破了软件设计的精髓所在。</p>
<h3 id="正交设计原则">正交设计原则</h3>
<ul>
<li>消除重复</li>
<li>分离关注点</li>
<li>缩小依赖范围</li>
<li>向稳定的方向依赖</li>
</ul>
<h2 id="实战">实战</h2>
<blockquote>
<p><strong>需求1：</strong> 存在一个学生的列表，查找一个年龄等于<code>18</code>岁的学生</p>
</blockquote>
<h3 id="快速实现">快速实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Student <span style="color:#a6e22e">findByAge</span><span style="color:#f92672">(</span>Student<span style="color:#f92672">[]</span> students<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span> i<span style="color:#f92672">&lt;</span>students<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>students<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 18<span style="color:#f92672">)</span>
      <span style="color:#66d9ef">return</span> students<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>上述实现存在很多设计的「坏味道」：</p>
<ul>
<li>缺乏弹性参数类型：只支持数组类型，<code>List, Set</code>都被拒之门外；</li>
<li>容易出错：操作数组下标，往往引入不经意的错误；</li>
<li>幻数：硬编码，将算法与配置高度耦合；</li>
<li>返回<code>null</code>：再次给用户打开了犯错的大门；</li>
</ul>
<h3 id="使用for-each">使用<code>for-each</code></h3>
<p>按照「最小依赖原则」，先隐藏数组下标的实现细节，使用<code>for-each</code>降低错误发生的可能性。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Student <span style="color:#a6e22e">findByAge</span><span style="color:#f92672">(</span>Student<span style="color:#f92672">[]</span> students<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Student s <span style="color:#f92672">:</span> students<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 18<span style="color:#f92672">)</span>
      <span style="color:#66d9ef">return</span> s<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<p><strong>需求2：</strong> 查找一个名字为<code>horance</code>的学生</p>
</blockquote>
<h3 id="重复设计">重复设计</h3>
<p><code>Copy-Paste</code>是最快的实现方法，但会产生「重复设计」。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Student <span style="color:#a6e22e">findByName</span><span style="color:#f92672">(</span>Student<span style="color:#f92672">[]</span> students<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Student s <span style="color:#f92672">:</span> students<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">().</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;horance&#34;</span><span style="color:#f92672">))</span>
      <span style="color:#66d9ef">return</span> s<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>为了消除重复，可以将「查找算法」与「比较准则」这两个「变化方向」进行分离。</p>
<h3 id="抽象准则">抽象准则</h3>
<p>首先将比较的准则进行抽象化，让其独立变化。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">StudentPredicate</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>Student s<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>将各个「变化原因」对象化，为此建立了两个简单的算子。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AgePredicate</span> <span style="color:#66d9ef">implements</span> StudentPredicate <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">;</span>
  
  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AgePredicate</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> age<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> age<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
  
  <span style="color:#a6e22e">@Override</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>Student s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> age<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NamePredicate</span> <span style="color:#66d9ef">implements</span> StudentPredicate <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">private</span> String name<span style="color:#f92672">;</span>
  
  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">NamePredicate</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
  
  <span style="color:#a6e22e">@Override</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>Student s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">().</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>name<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>此刻，查找算法的方法名也应该被「重命名」，使其保持在同一个「抽象层次」上。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Student <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span>Student<span style="color:#f92672">[]</span> students<span style="color:#f92672">,</span> StudentPredicate p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Student s <span style="color:#f92672">:</span> students<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>s<span style="color:#f92672">))</span>
      <span style="color:#66d9ef">return</span> s<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>客户端的调用根据场景，提供算法的配置。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">assertThat<span style="color:#f92672">(</span>find<span style="color:#f92672">(</span>students<span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> AgePredicate<span style="color:#f92672">(</span>18<span style="color:#f92672">)),</span> notNullValue<span style="color:#f92672">());</span>
assertThat<span style="color:#f92672">(</span>find<span style="color:#f92672">(</span>students<span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> NamePredicate<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;horance&#34;</span><span style="color:#f92672">)),</span> notNullValue<span style="color:#f92672">());</span>
</code></pre></div><h3 id="结构性重复">结构性重复</h3>
<p><code>AgePredicate</code>和<code>NamePredicate</code>存在「结构型重复」，需要进一步消除重复。经分析两个类的存在无非是为了实现「闭包」的能力，可以使用<code>lambda</code>表达式，「<code>Code As Data</code>」，简明扼要。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">assertThat<span style="color:#f92672">(</span>find<span style="color:#f92672">(</span>students<span style="color:#f92672">,</span> s <span style="color:#f92672">-&gt;</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 18<span style="color:#f92672">),</span> notNullValue<span style="color:#f92672">());</span>
assertThat<span style="color:#f92672">(</span>find<span style="color:#f92672">(</span>students<span style="color:#f92672">,</span> s <span style="color:#f92672">-&gt;</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">().</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;horance&#34;</span><span style="color:#f92672">)),</span> notNullValue<span style="color:#f92672">());</span>
</code></pre></div><h3 id="引入iterable">引入<code>Iterable</code></h3>
<p>按照「向稳定的方向依赖」的原则，为了适应诸如<code>List, Set</code>等多种数据结构，甚至包括原生的数组类型，可以将入参重构为重构为更加抽象的<code>Iterable</code>类型。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Student <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span>Iterable<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;</span> students<span style="color:#f92672">,</span> StudentPredicate p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Student s <span style="color:#f92672">:</span> students<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>s<span style="color:#f92672">))</span>
      <span style="color:#66d9ef">return</span> s<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<p><strong>需求3：</strong> 存在一个老师列表，查找第一个女老师</p>
</blockquote>
<h3 id="类型重复">类型重复</h3>
<p>按照既有的代码结构，可以通过<code>Copy Paste</code>快速地实现这个功能。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">TeacherPredicate</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>Teacher t<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Teacher <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span>Iterable<span style="color:#f92672">&lt;</span>Teacher<span style="color:#f92672">&gt;</span> teachers<span style="color:#f92672">,</span> TeacherPredicate p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Teacher t <span style="color:#f92672">:</span> teachers<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>t<span style="color:#f92672">))</span>
      <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>用户接口依然可以使用<code>Lambda</code>表达式。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">assertThat<span style="color:#f92672">(</span>find<span style="color:#f92672">(</span>teachers<span style="color:#f92672">,</span> t <span style="color:#f92672">-&gt;</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">female</span><span style="color:#f92672">()),</span> notNullValue<span style="color:#f92672">());</span>
</code></pre></div><p>如果使用<code>Method Reference</code>，可以进一步地改善表达力。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">assertThat<span style="color:#f92672">(</span>find<span style="color:#f92672">(</span>teachers<span style="color:#f92672">,</span> Teacher<span style="color:#f92672">::</span>female<span style="color:#f92672">),</span> notNullValue<span style="color:#f92672">());</span>
</code></pre></div><h3 id="类型参数化">类型参数化</h3>
<p>分析<code>StudentMacher/TeacherPredicate</code>, <code>find(Iterable&lt;Student&gt;)/find(Iterable&lt;Teacher&gt;)</code>的重复，为此引入「类型参数化」的设计。</p>
<p>首先消除<code>StudentPredicate</code>和<code>TeacherPredicate</code>的重复设计。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Predicate</span><span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>E e<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>再对<code>find</code>进行类型参数化设计。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> E <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span>Iterable<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> c<span style="color:#f92672">,</span> Predicate<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>E e <span style="color:#f92672">:</span> c<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>e<span style="color:#f92672">))</span>
      <span style="color:#66d9ef">return</span> e<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="型变">型变</h3>
<p>但<code>find</code>的类型参数缺乏「型变」的能力，为此引入「型变」能力的支持，接口更加具有可复用性。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> E <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span>Iterable<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">extends</span> E<span style="color:#f92672">&gt;</span> c<span style="color:#f92672">,</span> Predicate<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> E<span style="color:#f92672">&gt;</span> p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>E e <span style="color:#f92672">:</span> c<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>e<span style="color:#f92672">))</span>
      <span style="color:#66d9ef">return</span> e<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="复用lambda">复用<code>lambda</code></h3>
<blockquote>
<p>Parameterize all the things.</p>
</blockquote>
<p>观察如下两个测试用例，如果做到极致，可认为两个<code>lambda</code>表达式也是重复的。从「分离变化的方向」的角度分析，此<code>lambda</code>表达式承载的「比较算法」与「参数配置」两个职责，应该对其进行分离。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">assertThat<span style="color:#f92672">(</span>find<span style="color:#f92672">(</span>students<span style="color:#f92672">,</span> s <span style="color:#f92672">-&gt;</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">().</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Horance&#34;</span><span style="color:#f92672">)),</span> notNullValue<span style="color:#f92672">());</span>
assertThat<span style="color:#f92672">(</span>find<span style="color:#f92672">(</span>students<span style="color:#f92672">,</span> s <span style="color:#f92672">-&gt;</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">().</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Tomas&#34;</span><span style="color:#f92672">)),</span> notNullValue<span style="color:#f92672">());</span>
</code></pre></div><p>可以通过<code>「Static Factory Method」</code>生产<code>lambda</code>表达式，将比较算法封装起来；而配置参数通过引入「参数化」设计，将「逻辑」与「配置」分离，从而达到最大化的代码复用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StudentPredicates</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">StudentPredicates</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
  <span style="color:#f92672">}</span>

  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Predicate<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">age</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> age<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> s <span style="color:#f92672">-&gt;</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> age<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span> 
  
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Predicate<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">name</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> s <span style="color:#f92672">-&gt;</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">().</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>name<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import static</span> StudentPredicates.*<span style="color:#f92672">;</span>

assertThat<span style="color:#f92672">(</span>find<span style="color:#f92672">(</span>students<span style="color:#f92672">,</span> name<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;horance&#34;</span><span style="color:#f92672">)),</span> notNullValue<span style="color:#f92672">());</span>
assertThat<span style="color:#f92672">(</span>find<span style="color:#f92672">(</span>students<span style="color:#f92672">,</span> age<span style="color:#f92672">(</span>10<span style="color:#f92672">)),</span> notNullValue<span style="color:#f92672">());</span>
</code></pre></div><h3 id="组合查询">组合查询</h3>
<p>但是，上述将<code>lambda</code>表达式封装在<code>Factory</code>的设计是及其脆弱的。例如，增加如下的需求：</p>
<blockquote>
<p><strong>需求4：</strong> 查找年龄不等于18岁的女生</p>
</blockquote>
<p>最简单的方法就是往<code>StudentPredicates</code>不停地增加<code>「Static Factory Method」</code>，但这样的设计严重违反了<code>「OCP」(开放封闭)</code>原则。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StudentPredicates</span> <span style="color:#f92672">{</span>
  <span style="color:#f92672">......</span>

  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Predicate<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">ageEq</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> age<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> s <span style="color:#f92672">-&gt;</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> age<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span> 
  
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Predicate<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">ageNe</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> age<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> s <span style="color:#f92672">-&gt;</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> age<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span> 
<span style="color:#f92672">}</span>
</code></pre></div><p>从需求看，比较准则增加了众多的语义，再次运用「分离变化方向」的原则，可发现存在两类运算的规则:</p>
<ul>
<li>比较运算：<code>==, !=</code></li>
<li>逻辑运算：<code>&amp;&amp;, ||</code></li>
</ul>
<h4 id="比较语义">比较语义</h4>
<p>先处理比较运算的变化方向，为此建立一个<code>Matcher</code>的抽象：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Matcher</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">matches</span><span style="color:#f92672">(</span>T actual<span style="color:#f92672">);</span>
    
  <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Matcher<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">eq</span><span style="color:#f92672">(</span>T expected<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> actual <span style="color:#f92672">-&gt;</span> expected<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>actual<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
  
  <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Matcher<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">ne</span><span style="color:#f92672">(</span>T expected<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> actual <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">!</span>expected<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>actual<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<p>Composition everywhere.</p>
</blockquote>
<p>此刻，<code>age</code>的设计运用了「函数式」的思维，其行为表现为「高阶函数」的特性，通过函数的「组合式设计」完成功能的自由拼装组合，简单、直接、漂亮。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StudentPredicates</span> <span style="color:#f92672">{</span>
  <span style="color:#f92672">......</span>

  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Predicate<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">age</span><span style="color:#f92672">(</span>Matcher<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> m<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> s <span style="color:#f92672">-&gt;</span> m<span style="color:#f92672">.</span><span style="color:#a6e22e">matches</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">());</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><em>查找年龄不等于18岁的学生</em>，可以如此描述。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">assertThat<span style="color:#f92672">(</span>find<span style="color:#f92672">(</span>students<span style="color:#f92672">,</span> age<span style="color:#f92672">(</span>ne<span style="color:#f92672">(</span>18<span style="color:#f92672">))),</span> notNullValue<span style="color:#f92672">());</span>
</code></pre></div><h4 id="逻辑语义">逻辑语义</h4>
<p>为了使得逻辑「谓词」变得更加人性化，可以引入「流式接口」的<code>「DSL」</code>设计，增强表达力。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Predicate</span><span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>E e<span style="color:#f92672">);</span>

  <span style="color:#66d9ef">default</span> Predicate<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">and</span><span style="color:#f92672">(</span>Predicate<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> E<span style="color:#f92672">&gt;</span> other<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> e <span style="color:#f92672">-&gt;</span> test<span style="color:#f92672">(</span>e<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> other<span style="color:#f92672">.</span><span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><em>查找年龄不等于18岁的女生</em>，可以表述为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">assertThat<span style="color:#f92672">(</span>find<span style="color:#f92672">(</span>students<span style="color:#f92672">,</span> age<span style="color:#f92672">(</span>ne<span style="color:#f92672">(</span>18<span style="color:#f92672">)).</span><span style="color:#a6e22e">and</span><span style="color:#f92672">(</span>Student<span style="color:#f92672">::</span>female<span style="color:#f92672">)),</span> notNullValue<span style="color:#f92672">());</span>
</code></pre></div><h3 id="重复再现">重复再现</h3>
<p>仔细的读者可能已经发现了，<code>Student</code>和<code>Teacher</code>两个类也存在「结构型重复」的问题。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Student</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> male<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> age<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">male</span> <span style="color:#f92672">=</span> male<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
  
  <span style="color:#f92672">......</span>
  
  <span style="color:#66d9ef">private</span> String name<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> male<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Teacher</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Teacher</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> male<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> age<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">male</span> <span style="color:#f92672">=</span> male<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
  
  <span style="color:#f92672">......</span>
  
  <span style="color:#66d9ef">private</span> String name<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> male<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="级联反应">级联反应</h4>
<p><code>Student</code>与<code>Teacher</code>的结构性重复，导致<code>StudentPredicates</code>与<code>TeacherPredicates</code>也存在「结构性重复」。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StudentPredicates</span> <span style="color:#f92672">{</span>
  <span style="color:#f92672">......</span>

  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Predicate<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">age</span><span style="color:#f92672">(</span>Matcher<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> m<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> s <span style="color:#f92672">-&gt;</span> m<span style="color:#f92672">.</span><span style="color:#a6e22e">matches</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">());</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TeacherPredicates</span> <span style="color:#f92672">{</span>
  <span style="color:#f92672">......</span>

  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Predicate<span style="color:#f92672">&lt;</span>Teacher<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">age</span><span style="color:#f92672">(</span>Matcher<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> m<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> t <span style="color:#f92672">-&gt;</span> m<span style="color:#f92672">.</span><span style="color:#a6e22e">matches</span><span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">());</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>为此需要进一步消除重复。</p>
<h4 id="提取基类">提取基类</h4>
<p>第一个直觉，通过「提取基类」的重构方法，消除<code>Student</code>和<code>Teacher</code>的重复设计。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Human</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">protected</span> <span style="color:#a6e22e">Human</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> male<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> age<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">male</span> <span style="color:#f92672">=</span> male<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
    
  <span style="color:#f92672">...</span>
  
  <span style="color:#66d9ef">private</span> String name<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> male<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>从而实现了进一步消除了<code>Student</code>和<code>Teacher</code>之间的重复设计。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> <span style="color:#66d9ef">extends</span> Human <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Student</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> male<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>name<span style="color:#f92672">,</span> age<span style="color:#f92672">,</span> male<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Teacher</span> <span style="color:#66d9ef">extends</span> Human <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Teacher</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> male<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>name<span style="color:#f92672">,</span> age<span style="color:#f92672">,</span> male<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="类型界定">类型界定</h4>
<p>此时，可以通过引入「类型界定」的泛型设计，使得<code>StudentPredicates</code>与<code>TeacherPredicates</code>合二为一，进一步消除重复设计。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HumanPredicates</span> <span style="color:#f92672">{</span>
  <span style="color:#f92672">......</span>
  
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>E <span style="color:#66d9ef">extends</span> Human<span style="color:#f92672">&gt;</span> 
    Predicate<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">age</span><span style="color:#f92672">(</span>Matcher<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> m<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> s <span style="color:#f92672">-&gt;</span> m<span style="color:#f92672">.</span><span style="color:#a6e22e">matches</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">());</span>
  <span style="color:#f92672">}</span> 
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="消灭继承关系">消灭继承关系</h4>
<p><code>Student</code>和<code>Teacher</code>依然存在「结构型重复」的问题，可以通过<code>Static Factory Method</code>的设计方法，并让<code>Human</code>的构造函数「私有化」，删除<code>Student</code>和<code>Teacher</code>两个子类，彻底消除两者之间的「重复设计」。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Human</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Human</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> male<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> age<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">male</span> <span style="color:#f92672">=</span> male<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
  
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Human <span style="color:#a6e22e">student</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> male<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Human<span style="color:#f92672">(</span>name<span style="color:#f92672">,</span> age<span style="color:#f92672">,</span> male<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
  
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Human <span style="color:#a6e22e">teacher</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> male<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Human<span style="color:#f92672">(</span>name<span style="color:#f92672">,</span> age<span style="color:#f92672">,</span> male<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
  
  <span style="color:#f92672">......</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="消灭类型界定">消灭类型界定</h4>
<p><code>Human</code>的重构，使得<code>HumanPredicates</code>的「类型界定」变得多余，从而进一步简化了设计。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HumanPredicates</span> <span style="color:#f92672">{</span>
  <span style="color:#f92672">......</span>
  
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Predicate<span style="color:#f92672">&lt;</span>Human<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">age</span><span style="color:#f92672">(</span>Matcher<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> m<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> s <span style="color:#f92672">-&gt;</span> m<span style="color:#f92672">.</span><span style="color:#a6e22e">matches</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">());</span>
  <span style="color:#f92672">}</span> 
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="绝不返回null">绝不返回<code>null</code></h3>
<blockquote>
<p>Billion-Dollar Mistake</p>
</blockquote>
<p>在最开始，我们遗留了一个问题：<em><code>find</code>返回了<code>null</code></em>。用户调用返回<code>null</code>的接口时，常常忘记<code>null</code>的检查，导致在运行时发生<code>NullPointerException</code>异常。</p>
<p>按照「向稳定的方向依赖」的原则，<code>find</code>的返回值应该设计为<code>Optional&lt;E&gt;</code>，使用「类型系统」的特长，取得如下方面的优势：</p>
<ul>
<li>显式地表达了不存在的语义；</li>
<li>编译时保证错误的发生；</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> java.util.Optional<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> Optional<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span>Iterable<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">extends</span> E<span style="color:#f92672">&gt;</span> c<span style="color:#f92672">,</span> Predicate<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> E<span style="color:#f92672">&gt;</span> p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>E e <span style="color:#f92672">:</span> c<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>e<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">return</span> Optional<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">return</span> Optional<span style="color:#f92672">.</span><span style="color:#a6e22e">empty</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="回顾">回顾</h3>
<p>通过<code>4</code>个需求的迭代和演进，通过运用「正交设计」和「组合式设计」的基本思想，加深对「正交设计基本原则」的理解。</p>
<h2 id="鸣谢">鸣谢</h2>
<p>「正交设计」的理论、原则、及其方法论出自前<code>ThoughtWorks</code>软件大师「袁英杰」先生。英杰既是我的老师，也是我的挚友；他高深莫测的软件设计的修为，及其对软件设计独特的哲学思维方式，是我等后辈学习的楷模。</p>
</div>
        </div>
          
        
      </div>
    </div>
  </section>
  

  
  <section class="pb-50">
    <div class="container">
      <div class="row justify-content-center" data-aos="fade-up">
        <div class="col-lg-6 col-md-9 text-center mb-40">
          <h2 class="section-title">Recent Articles</h2>
        </div>
      </div>
      <div class="row">
        
        <div class="col-lg-4 col-md-6 mb-40">
          <div class="card border-0 h-100">
            <a class="d-flex flex-fill align-items-center" href="https://joycode-art.github.io/blog/01-test-design/"><img class="card-img-top rounded" src="https://joycode-art.github.io/images/blogs/012.png" alt="blog-image"></a>
            <div class="p-25 pb-0">
              <div class="post-category position-relative mb-15"><a
                href="/categories/%e5%bc%80%e5%8f%91%e8%80%85%e6%b5%8b%e8%af%95" class="text-black-200 font-weight-600 ml-1">开发者测试 </a>
                
              </div>
              <a class="h4 font-weight-bold d-block mb-15" href="https://joycode-art.github.io/blog/01-test-design/">可测试性设计</a>
              <div class="post-meta font-weight-600 mb-15">14 Mar, 2020<span class="mx-2">|</span>1 Mins Read
              </div>
              <p>架构是完美的，实现是骨干的 在切入这个主题之前，先看一个“完美架构图”的问题。我相信你肯定看过无数多个类似这样的架构图，每个框框都排布整齐，而且显得特别高大上。
但是，实际的系统实现真的是这样吗？未必。系统往往充满了各种变化、约束、限制和条件，这些隐式的概念往往是不能“公诸于世”的。设计存在就是为了控制住系统实现的复杂度，应对软件的变化，并将这些隐式的概念显式化。
但是，我们也不能否认架构存在的意义，至少它利于个体之间的交流，利于与客户的沟通，并在更高维度的角度看待问题，并指导进一步的系统设计和实现。
分层架构 理论上，任何复杂的系统都可以用一个main函数实现，但事实上没人那么干，分层架构便是一种最朴素的系统分解和组合的架构思维，并符合大部分人的心智模型。
分层架构最大的好处在于提供了层间抽象和隔离的机制，并非常容易在工程上保证层间的契约不被破坏。例如，分层架构遵守单向依赖原则，当有人违背架构原则而引入循环依赖，采用一些架构看护的工具，使能自动检查这些行为的。
其次，分层架构有利于开展模块间并行开发和协作。每个模块只要边界清晰，便可以独立开发了。但是，任何的软件工程方法的实践，必然存在它的边际效应。
同层模块间依赖混乱、模块内实现一团乱麻， 这是很多系统实现的真实写照。虽然，层间调用和约定都得到了很好的约束和保证，但同层内的模块间的耦合程度极高，相互引用和依赖，缺失架构原则的约束和检查。</p>
            </div>
          </div>
        </div>
        
        <div class="col-lg-4 col-md-6 mb-40">
          <div class="card border-0 h-100">
            <a class="d-flex flex-fill align-items-center" href="https://joycode-art.github.io/blog/02-impl-design/"><img class="card-img-top rounded" src="https://joycode-art.github.io/images/blogs/007.png" alt="blog-image"></a>
            <div class="p-25 pb-0">
              <div class="post-category position-relative mb-15"><a
                href="/categories/%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1" class="text-black-200 font-weight-600 ml-1">软件设计 </a>
                
              </div>
              <a class="h4 font-weight-bold d-block mb-15" href="https://joycode-art.github.io/blog/02-impl-design/">实现正交设计</a>
              <div class="post-meta font-weight-600 mb-15">14 Mar, 2020<span class="mx-2">|</span>5 Mins Read
              </div>
              <p>软件设计的目标 软件设计就是为了完成如下目标，其可验证性、重要程度依次减低。
 实现功能 易于重用 易于理解 没有冗余  实现功能 实现功能的目标压倒一起，这也是软件设计的首要标准。如何判定系统功能的完备性呢？通过所有测试用例。</p>
            </div>
          </div>
        </div>
        
        <div class="col-lg-4 col-md-6 mb-40">
          <div class="card border-0 h-100">
            <a class="d-flex flex-fill align-items-center" href="https://joycode-art.github.io/blog/04-performance/"><img class="card-img-top rounded" src="https://joycode-art.github.io/images/blogs/005.png" alt="blog-image"></a>
            <div class="p-25 pb-0">
              <div class="post-category position-relative mb-15"><a
                href="/categories/%e7%b3%bb%e7%bb%9f%e6%80%a7%e8%83%bd%e5%b7%a5%e7%a8%8b" class="text-black-200 font-weight-600 ml-1">系统性能工程 </a>
                
              </div>
              <a class="h4 font-weight-bold d-block mb-15" href="https://joycode-art.github.io/blog/04-performance/">系统性能优化</a>
              <div class="post-meta font-weight-600 mb-15">14 Mar, 2020<span class="mx-2">|</span>0 Mins Read
              </div>
              <p></p>
            </div>
          </div>
        </div>
        
      </div>
    </div>
  </section>
  



<footer class="bg-light-gray has-shapes has-bg-brash bg-brash-top" style="padding-top: 0pt">

  <div class="footer-bottom">
    <div class="container">
      <div class="row">
        <div class="col-12">
          <div class="block border-top text-center content">Copyright @ <a href="https://joycode.art/">卓酷软件技术（西安）有限责任公司</a> All Rights Reserved     备案号：陕ICP备2020017028号</a>
          </div>
        </div>
      </div>
    </div>
  </div>
</footer>



<a href="#top" class="btn btn-primary scroll-to-top-btn smooth-scroll position-fixed"><svg
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="32" height="32">
    <path id="Layer" fill="currentColor"
      d="M7.2 19.2L15.2 11.2C15.68 10.71 16.43 10.68 16.96 11.08L17.08 11.2L25.08 19.2L23.2 21.08L16.14 14.02L9.08 21.08L7.2 19.2Z" />
    </svg></a>


<!-- JS Plugins -->

<script src="https://joycode-art.github.io/plugins/jQuery/jquery.min.js"></script>

<script src="https://joycode-art.github.io/plugins/bootstrap/bootstrap.min.js"></script>

<script src="https://joycode-art.github.io/plugins/slick/slick.min.js"></script>

<script src="https://joycode-art.github.io/plugins/shuffle/shuffle.min.js"></script>

<script src="https://joycode-art.github.io/plugins/aos/aos.js"></script>


<!-- Main Script -->

<script src="https://joycode-art.github.io/js/script.min.js"></script></body>

</html>